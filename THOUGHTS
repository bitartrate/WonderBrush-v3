Resourcen

Noch mehr Dinge als jetzt schon (Fill, Path) könnten Resourcen sein, zum Beispiel auch einfache Farben. Im Eigenschaften Feld könnte man diese Resourcen "veröffentlichen" können, was sie in die globale Resourcen Liste einträgt. Von dort könnte man Resourcen anderen Objekten zuweisen oder Resourcen erzeugen, die ableiten von anderen Resourcen, wie beispielsweise "Shades" was eine Color-Resource ist, welche auf einer anderen Color-Resource basiert und Parameter abändern kann (Sättigung, Helligkeit, ...). Resourcen könnten dann an beliebiger Stelle referenziert werden. Eine Color-Resource in einem Gradient-Step uswusf.


Dekorationen

Gegenwärtig ist es bei Shape und Rect Objekten möglich, einen "Fill" und einen "Stroke" Paint zu definieren. Besonders flexibel ist das noch nicht. So ähnlich wie in Icon-O-Matic könnte man das Konzept der "Decorations" erfinden, wo man bestimmte Typen von Objekten (Shape, Rect, Text) erst einmal als Vektorform auffasst. Vielleicht leiten diese Objekte alle von einer Basisklasse ab, welche eine agg::path_storage liefert.
Standardmäßig würden diese Formen mit einem bestimmten "Paint" gefüllt. Zusätzlich kann man dann beliebig viele Dekorationen hinzufügen, die jeweils einen eigenen Paint und sogar eine zum Objekt relative Transformation haben. Die Dekorations basieren auf der Vektorform des Mutterobjekts und verändern diese entsprechend ihres Typs und ihrer Parameter. Diese Form der Dekorations könnte als Unterobjekt des Mutterobjekts dargestellt werden. Das hätte den Vorteil, dass man sie einklappen kann und das gesamte Gebilde als einzelnes Objekt im Layertree funktioniert.
Gleichzeitig wäre es aber auch noch flexibler, wenn man die Dekorations optional von ihrem Mutterobjekt abkoppeln und an beliebiger Stelle im Layertree einsetzen könnte. Als eigenständige Objekte dürfen Decorations natürlich selbst wieder als Mutterobjekt für weitere Decorations fungieren.


FontManager

In einem GlyphCache Eintrag werden entweder Bitmap- oder Pfad-Daten komprimiert in einem Puffer abgelegt. WonderBrush braucht quasi nur Glyphen als Vektorpfade, die Optimierung der Bitmap-Glyphen lohnt kaum. Es funktioniert allerdings nicht, gleich fertige Pfade zu cachen, weil agg::path_storage nicht thread-safe ist. Mehrere Threads würden sich gegenseitig den internen Iterator-Mechanismus durcheinander bringen. Vielleicht lohnt es, einen Iterator für path_storage zu implementieren und in jedem Thread eine Instanz zu verwenden. Ansonsten kann es nicht funktionieren, FontEngine::init_embedded_adaptors() so wie jetzt aufzurufen, wenn dadurch der Puffer aus dem GlyphCache in ein path_storage Objekt der FontEngine entpackt wird. Das ist noch viel weniger thread-safe. Stattdessen sollte es eine Art GlyphCacheExtractor Klasse geben, in welche die "Adapter" von FontEngine
verschoben werden.


Rendern mit Zoomstufe

Rein-/Rauszoomen sind zwei völlig verschiedene Paar Schuhe. Wenn man reingezoomt ist, muss man einen geringen Ausschnitt des Dokuments in Originalauflösung berechnen und vergrößert darstellen. Wenn man rausgezoomt ist, muss man viel weniger Pixel berechnen, als für die Originalauflösung erforderlich. Würde man alle Pixel berechnen und dann nur lückenhaft darstellen, ergebe sich zudem eine hässliche Darstellung, da ist es doch viel einfacher, so zu tun, als wäre die Originalauflösung kleiner und das Dokument so zu berechnen. Photoshop scheint manche Zoomstufen zu filtern (25%, 50%), aber mit dem vorgeschlagenen Ansatz wäre jede Zoomstufe quasi "perfekt gefiltert".


Blockweise Bitmaps und Caches

Es ist sinnvoll, die Dokumentansicht zu einem bestimmten Objektlevel zu cachen. Vielleicht wäre es von Vorteil, wenn man diesen Cache in gleichmäßige Blöcke (Ausschnitte aus der Ansicht) unterteilt, die jeweils ein unterschiedliches Objektlevel enthalten können. Braucht man beim Rendern einen (Teil von einem) Cacheblock, stellt aber fest, dass dieser veraltet ist, so erweitert man das Rendering einfach um die Fläche des gesamten Blocks, so dass der Block beim nächsten Rendering komplett gültig vorliegt.


An welcher Stelle sind die Caches im Objektbaum, auch jeweils an den Knoten?


Inwiefern soll es auf Festplatte ausgelagerte Bitmapdaten geben?

BitmapData
	-> Repräsentation von BitmapDaten
	-> nur eine globale Instanz derselben Daten
	-> referenzierbar

BitmapManager
	-> Managed BitmapData Objekte
	-> Applikationsweit nur eine Instanz

BitmapObjekt
	-> neue Objekte kreieren neue BitmapData Instanz und übergibt an
	   BitmapManager
	-> referenziert BitmapData
	-> eigentlich RechteckObjekt mit Bitmap-Füllung


Applikationsweiter "FillCache", könnte auch BitmapManager beinhalten. Bitmaps werden allerdings immer gemeinsam benutzt.

Fill
FillColor
FillGradient
FillBitmap

Ein "Style" ist nicht wie bei Icon-O-Matic die Füllung, sondern eine Art Container für verschiedene Eigenschaften. Nicht gesetzte Eigenschaften könnten hierarchisch vererbt werden.

Objekte können einen privaten Style haben oder der Style kann öffentlich werden und dann von anderen Objekten benutzt werden. Die Änderungen an dem Style durch irgendeines der Objekte werden in allen Objekten sichtbar.

Wie in Icon-O-Matic könnte man nicht nur globale Styles, sondern auch Füllungen und Pfade verfügbar machen. Allerdings optional, nicht standardmäßig bei neuen Objekten.

Füllungen müssen optional einen Alphakanal (Bitmap) unterstützen. Jedenfalls so, dass man mit dem Fülleimer ins Bild klicken kann und dann nicht nur mit einer Farbe, sondern auch mit allen anderen Fülltypen füllen kann.

Füllfarben sollten auch als "Schattierung" einer anderen Farbe auftreten können. Wenn die Hauptfarbe gelöscht wird, erscheint ein Bestätigungsdialog, ob alle Schattierungen in normale Farben umgewandelt werden sollen. Alternativ könnte man auch eine zusätzliche Eigenschaft im Style verwalten, die dafür sorgt, dass eine Füllung abgedunkelt oder sonst wie verändert wird.


Layouting:
Layouting bedeutet, dass der Objektbaum traversiert wird und Abhängigkeiten final aufgelöst werden. Zum Beispiel könnte eine Objektgröße von der aktuellen Fontgröße abhängen, wobei der Font nur in einem übergeordneten Objekt gesetzt ist. Da die Tools auch fertig "gelayoutete" Objektparameter benötigen werden, ist es sinnvoll, das Layout auf dem Originaldokument durchzuführen. Dazu müssten Veränderungen eines Objektes darauf hinweisen, dass ein Layout das Unterbaums nötig ist. Alternativ könnten absolute Parameter im Originalobjektbaum immer live aufgelöst werden, aber der explizite Layoutvorgang könnte es erleichtern, die Regionen zum Neurendern zu wissen. Prinzipiell ist auch ein Layout der Snapshots notwendig, und zwar asynchron vor jedem Rendervorgang. Hierbei können zum Beispiel der aktuelle Zoom und Scrolloffset in die globalen Matrizen einfließen, welche im Originaldokument außen vor bleiben sollten.


PropertyObject Interface erweitern:
	-> Abfrage nach Anzahl von "PropertyObjects" oder "PropertyCategory" oder
	   "Sub-PropertyObject" (nested PropertyObjects?)
	-> einklappbare Abschnitte für jede einzelne PropertyCategory in ListView
	-> PropertyCategory unterstützt Hinzufügen von Properties.
	-> So wird dann beispielsweise der Style eines Objects im selben
	   PropertyListView anzeig- und editierbar.

Alternative Ansicht für die Layer und Objekte: Die Ansicht zeigt nur die Objekte des aktuellen Layers. Bei Doppelklick auf ein Layer verschiebt sich die Ansicht nach links um ihre Breite (mit schnellem Scrolleffekt) und zeigt jetzt die Objekte des geklickten Layers. Man kann in der Hierarchie nach rechts (rein/tiefer) und links (raus/höher) über Pfeilknöpfe, zusätzlich könnte es ein "Breadcrumb" Control geben, so dass man im aktuellen Pfad springen kann. Dieser könnte von oben nach unten verlaufen. Der Pfad ändert sich durch expliziten Doppelklick auf ein Layer, bleibt aber ansonsten stabil, wenn der Nutzer nur kurz zwischen den Ebenen hin- und herspringt.


Slice-Tool:
Slices sind rechteckige Bereiche auf der Bildfläche, die der Nutzer anlegen, definieren und benennen kann. Beim Exportieren kann man alle Slices exportieren, was jeweils den Bereich unter dem Namen exportiert. Ausgewählt wird der Zielordner und vielleicht ein Dateiname, wo ein Wildcard mit dem Namen des jeweiligen Slices ersetzt wird.
